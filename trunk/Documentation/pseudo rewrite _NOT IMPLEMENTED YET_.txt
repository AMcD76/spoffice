interface IMusicDownloader {
	DownloadTrack(PlayableTrack track);
	DownloadImage(PlayableTrack track);
}
interface IMusicPlayer {
	TotalBytesPlayed { get; set; }
	PlayTrack(PlayableTrack track);
}

class SpotifyDownloader implemnts IMusicDownloader {
	SpotifyDownloader(string musicCachePath, string imageCachePath){
	}
	DownloadTrack(PlayableTrack track){
		if (track exists){
			track.OnDownloaded();
		}else {
			while (downloading){
				sleep
			}
			if (error){
				track.OnDownloadError();
			}else {
				track.OnDownloaded();
			}
		]
	}
	DownloadImage(Track track){
		
	}
}
class MusicPlayer implemnts IMusicPlayer {
	MusicPlayer (string musicCachePath, int bytesPlayed) {
		TotalBytesPlayed = bytesPlayed;
	}
	TotalBytesPlayed {
		get; set;
	}
	PlayTrack(Track track){
		while (playing){
			sleep
			TotalBytesPlayed += bytes;
		}
		track.onTrackPlayed();
	}
}
class MusicService {
	List<PlayableTrack> UpcomingTracks; // upcoming tracks
	int VoteCount; // number of votes for current track
	int TrackBufferSize = 4; // number of tracks in the buffer
	IMusicDownloader Downloader;
	IMusicPlayer Player;
	ITrackRepository TrackRepository;
	Track CurrentTrack {
		get {
			return UpcomingTracks[0];
		}
	}
	MusicService (IMusicDownloader downloader, IMusicPlayer player, ITrackRepository trackRepository){
		Downloader = downloader;
		Player = player;
		TrackRepository = trackRepository;
	}
	AddVote (Guid userId){
            if (!Votes.Contains(userId))
            {
                Votes.Add(userId);
                return true;
            }
            return false;
	}
	Skip (){
		CurrentTrack.Stop();
	}
	OnTrackDownloaded(PlayableTrack track){
		track.removeOnTrackPlayedDelegate();
	}
	OnTrackPlayed(PlayableTrack track){
		track.removeOnTrackDownloadedDelegate();
		TrackRepository.AddTrackToHistory(track);
		UpcomingTracks.Remove(track)
	}
	OnTrackDownloadError(PlayableTrack track){
		track.removeOnTrackDownloadedDelegate();
	}
	OrganizePlaylist (){
		if (CurrentTrack != nul && CurrentTrack.State == TrackState.Downloaded)
			CurrentTrack.Play()
			Votes.Clear();			
		}
		
		MissingTracksCount = TrackBufferSize - UpcomingTracks.Length;
		if (MissingTracksCount > 0){
			var Tracks = TrackRepository.GetRandomTracks(MissingTracksCount, ExcludeThese);
			foreach (Tracks as (PlayableTrack)track){				
				track.Player = MusicPlayer;
				track.Downloader = MusicDownloader;
				track.OnTrackDownloaded += new Track.TrackDownloadedDlg(OnTrackDownloaded);
				track.OnTrackDownloadError += new Track.TrackErrorDlg(OnTrackDownloadError);
				track.OnTrackPlayed += new Track.TrackPlayedDlg(OnTrackPlayed);
				UpcomingTracks.Add(track);
			}
		}
		
		foreach (PlayableTrack track in UpcomingTracks){
			if (track.State == TrackState.New){
				track.Download();
				break;
			}
		}
		
	}
	
}
class TrackState = {
	New,
	Downloading,
	Downloaded,
	Failed,
	Playing,
	Played
}
class PlayableTrack extends Track{
	State = TrackState.New,
	IMusicPlayer Player;
	IMusicDownloader Downloader;
	PlayableTrack (IMusicDownloader downloader, IMusicPlayer player){
		Downloader = downloader;
		Player = player;
	}
	Play(){
		State = TrackState.Playing
		Player.PlayTrack(this);
	}
	Stop(){
		if (Player != null){
			Player.Stop()
		}
	}
	OnPlayed(){
		State = TrackState.Played;
		fire OnTrackPlayed(this);
	}
	Download (){
		State = TrackState.Downloading
		Downloader.DownloadTrack(this);
	}
	OnDownloaded(){
		State = TrackState.Downloaded
		fire OnTrackDownloaded(this);
	}
	OnDownloadError(){
		State = TrackState.Failed
		fire OnDownloadError(this);
	}
}